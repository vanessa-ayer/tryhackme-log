<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<title>{{ page.title }} - {{ site.title }}</title>
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<link
			rel="stylesheet"
			href="{{ '/assets/css/custom.css' | relative_url }}"
		/>
	</head>
	<body>
		<div class="site">
			<header class="site-header post-top">
				<h2 class="home-link">
					<a href="{{ site.baseurl }}/" aria-label="Return to Theme Demo home">
						&lt; TryHackMe Theme Demo
					</a>
				</h2>
				{% include xpbar.html %}
			</header>

			{% if site.design_mode %}
			<p class="demo-banner" role="note">
				<strong>Demo mode:</strong> This page showcases the theme layout. It’s a
				design prototype, not an active room log.
			</p>
			{% endif %}

			<main class="site-content">
				<h1 class="type-header title" data-text="{{ page.title }}">
					<span class="type-target"></span><span class="cursor"></span>
				</h1>

				<p class="post-meta">
					$ logged by <span class="author">Vanessa Ayer</span>
				</p>

				{{ content }}
				<hr class="divider" />

				<p class="return-link">
					<a
						href="{{ site.baseurl }}/"
						aria-label="Exit room and return to home"
					>
						<span class="type-target" data-text="&lt; exit room"></span>
						<span class="cursor"></span>
					</a>
				</p>
			</main>

			<footer class="site-footer">
				<p>Made by Vanessa • <small>TryHackMe Journey</small></p>
			</footer>
		</div>

		<script>
			(function () {
				// --- config ---
				var speedPerChar = 28; // ms per character (typing speed)
				var triggerEarly = '0px 0px -20% 0px'; // start typing when element is 80% into viewport

				function typeText(target, text, speed, done) {
					var i = 0;
					(function tick() {
						target.textContent = text.slice(0, i++);
						if (i <= text.length) setTimeout(tick, speed);
						else if (done) done();
					})();
				}

				// -------- Headers (H1 title + H2 section headers) --------
				var headers = [].slice.call(document.querySelectorAll('.type-header'));

				function observeHeaders() {
					if (!headers.length) return;

					// Fallback: if IO unsupported, type all immediately
					if (!('IntersectionObserver' in window)) {
						headers.forEach(function (h) {
							var tgt = h.querySelector('.type-target');
							if (tgt)
								typeText(tgt, h.getAttribute('data-text') || '', speedPerChar);
						});
						// still type exit link
						observeExit(true);
						return;
					}

					var seen = new WeakSet();
					var ioHeaders = new IntersectionObserver(
						function (entries) {
							entries.forEach(function (entry) {
								if (entry.isIntersecting && !seen.has(entry.target)) {
									seen.add(entry.target);
									var el = entry.target;
									var tgt = el.querySelector('.type-target');
									if (tgt) {
										typeText(
											tgt,
											el.getAttribute('data-text') || '',
											speedPerChar
										);
									}
									ioHeaders.unobserve(el);
								}
							});
						},
						{ root: null, rootMargin: triggerEarly, threshold: 0 }
					);

					headers.forEach(function (h) {
						ioHeaders.observe(h);
					});
				}

				// -------- Exit link (< exit room >) --------
				function observeExit(forceImmediate) {
					var exitWrapper = document.querySelector('.return-link');
					var exitTarget = document.querySelector('.return-link .type-target');
					if (!exitWrapper || !exitTarget) return;

					var text = exitTarget.getAttribute('data-text') || '';
					var started = false;

					function startExit() {
						if (started) return;
						started = true;
						typeText(exitTarget, text, speedPerChar);
					}

					function inView(el) {
						var r = el.getBoundingClientRect();
						return r.top < window.innerHeight && r.bottom > 0;
					}

					// If asked or already visible on load → type now
					if (forceImmediate || inView(exitWrapper)) {
						startExit();
						return;
					}

					// Best case: IntersectionObserver
					if ('IntersectionObserver' in window) {
						var io = new IntersectionObserver(
							function (entries) {
								entries.forEach(function (e) {
									if (e.target === exitWrapper && e.isIntersecting) {
										startExit();
										io.unobserve(exitWrapper);
									}
								});
							},
							{ root: null, rootMargin: triggerEarly, threshold: 0 }
						);
						io.observe(exitWrapper);
					}

					// Fallback: scroll/resize listener
					function onScroll() {
						if (!started && inView(exitWrapper)) {
							startExit();
							window.removeEventListener('scroll', onScroll, { passive: true });
							window.removeEventListener('resize', onScroll);
						}
					}
					window.addEventListener('scroll', onScroll, { passive: true });
					window.addEventListener('resize', onScroll);
				}

				// Kick off
				observeHeaders();
				observeExit(false);
			})();
		</script>
	</body>
</html>
