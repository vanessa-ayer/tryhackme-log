<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<title>{{ page.title }} - {{ site.title }}</title>
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<link
			rel="stylesheet"
			href="{{ '/assets/css/custom.css' | relative_url }}"
		/>
	</head>
	<body>
		<div class="site">
			<header class="site-header">
				<h1 class="site-title">
					<a href="{{ site.baseurl | prepend: site.url }}">{{ site.title }}</a>
				</h1>
				<p class="site-desc">{{ site.description }}</p>
				<div class="xpbar">
					<div class="xp-meta">ðŸ’€ Level 1 â€” 50 XP / 500 XP</div>
					<div class="xp-track">
						<div class="xp-fill" style="width: 10%"></div>
					</div>
				</div>
			</header>

			<main class="site-content">
				<h1 class="type-header title" data-text="{{ page.title }}">
					<span class="type-target"></span><span class="cursor"></span>
				</h1>

				<p class="post-meta">
					$ logged by <span class="author">Vanessa Ayer</span>
				</p>

				{{ content }}
				<hr class="divider" />

				<p class="return-link">
					<a
						href="{{ site.baseurl }}/"
						aria-label="Exit room and return to home"
					>
						<span class="type-target" data-text="&lt; exit room"></span>
						<span class="cursor"></span>
					</a>
				</p>
			</main>

			<footer class="site-footer">
				<p>Made by Vanessa â€¢ <small>TryHackMe Journey</small></p>
			</footer>
		</div>
		<script>
			(function () {
				// --- config you can tweak ---
				var speedPerChar = 28; // ms per character (higher = slower)
				var triggerEarly = '0px 0px -20% 0px'; // starts typing when 80% into viewport
				var exitSpeedPerChar = 28;

				// Typing helper
				function typeText(target, text, speed, done) {
					var i = 0;
					(function tick() {
						target.textContent = text.slice(0, i++);
						if (i <= text.length) {
							setTimeout(tick, speed);
						} else {
							done && done();
						}
					})();
				}

				// Find headers to type (title + all section headers you marked up)
				var headers = [].slice.call(document.querySelectorAll('.type-header'));

				// Observe each header; type once on first view, new update
				function observeHeaders() {
					if (!('IntersectionObserver' in window)) {
						// Fallback: type all immediately
						headers.forEach(function (h) {
							var tgt = h.querySelector('.type-target');
							if (!tgt) return;
							typeText(tgt, h.getAttribute('data-text') || '', speedPerChar);
						});
						typeExitIfPresent(); // also type exit link
						return;
					}

					var seen = new WeakSet();
					var io = new IntersectionObserver(
						function (entries) {
							entries.forEach(function (entry) {
								if (entry.isIntersecting && !seen.has(entry.target)) {
									seen.add(entry.target);
									var el = entry.target;
									var tgt = el.querySelector('.type-target');
									if (!tgt) return;
									typeText(
										tgt,
										el.getAttribute('data-text') || '',
										speedPerChar
									);
									io.unobserve(el);
								}
							});
						},
						{ root: null, rootMargin: triggerEarly, threshold: 0 }
					);

					headers.forEach(function (h) {
						io.observe(h);
					});

					// Observe the "exit room" link too
					observeExit(io);
				}

				// Observe footer "exit room" typing when it scrolls into view
				function observeExit(io) {
					var exitTarget = document.querySelector('.return-link .type-target');
					if (!exitTarget) return;

					var exitWrapper = document.querySelector('.return-link');
					if (!exitWrapper) return;

					var done = false;
					function startExit() {
						if (done) return;
						done = true;
						var text = exitTarget.getAttribute('data-text') || '';
						typeText(exitTarget, text, exitSpeedPerChar);
					}

					if (io) {
						io.observe(exitWrapper);
						// augment the same observer with exit typing
						var origCB = io.callback || null;
						io.callback = function (entries, obs) {
							entries.forEach(function (e) {
								if (e.target === exitWrapper && e.isIntersecting) startExit();
							});
							if (origCB) origCB(entries, obs);
						};
					} else {
						// No IO support, type as fallback
						startExit();
					}
				}

				function typeExitIfPresent() {
					var exitTarget = document.querySelector('.return-link .type-target');
					if (!exitTarget) return;
					var text = exitTarget.getAttribute('data-text') || '';
					typeText(exitTarget, text, exitSpeedPerChar);
				}

				// Kick off
				observeHeaders();
			})();
		</script>
	</body>
</html>
